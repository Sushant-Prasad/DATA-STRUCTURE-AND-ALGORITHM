/*
===========================================================
TITLE
===========================================================
Generate All Unique Permutations of a String (Using Swapping + Set)

===========================================================
PROBLEM STATEMENT
===========================================================
You are given three integers:
• n1 → number of times character 'a' appears
• n2 → number of times character 'b' appears
• n3 → number of times character 'c' appears

Using these values, form a string consisting of:
- 'a' repeated n1 times
- 'b' repeated n2 times
- 'c' repeated n3 times

Your task is to generate and print **all unique permutations**
of the constructed string.

Duplicate permutations must NOT be printed.

===========================================================
INPUT FORMAT
===========================================================
• Three integers n1, n2, n3
  (each read from standard input)

Example:
1
1
1

===========================================================
OUTPUT FORMAT
===========================================================
• Print all unique permutations of the string
• Each permutation should be printed on a new line

===========================================================
INTUITION
===========================================================
A permutation can be generated by:
• Fixing one character at the current index
• Recursively permuting the remaining characters

However, since characters may repeat:
• Duplicate permutations can be generated
• A Set is used to store only unique permutations

===========================================================
APPROACH
===========================================================
1) Build the string using given counts of 'a', 'b', and 'c'
2) Convert the string into a character array
3) Use recursion and swapping to generate permutations
4) Store each generated permutation into a Set
5) Print all unique permutations from the Set

===========================================================
EXAMPLE
===========================================================
Input:
n1 = 1, n2 = 1, n3 = 1

Constructed string:
"abc"

Output:
abc
acb
bac
bca
cab
cba

===========================================================
DRY RUN
===========================================================
Initial string: "abc"

Fix index 0:
- Swap(0,0) → "abc"
  Fix index 1 → generate "abc", "acb"

- Swap(1,0) → "bac"
  Fix index 1 → generate "bac", "bca"

- Swap(2,0) → "cba"
  Fix index 1 → generate "cba", "cab"

Set ensures only unique permutations are stored.

===========================================================
KEY POINTS
===========================================================
• Swapping allows in-place permutation generation
• Backtracking restores original order
• Set removes duplicate permutations
• Works even when characters repeat

===========================================================
TIME COMPLEXITY
===========================================================
O(n! × n)
- n! permutations generated
- Each permutation conversion costs O(n)

===========================================================
SPACE COMPLEXITY
===========================================================
O(n! × n)
- Set stores all unique permutations

===========================================================
SPECIAL NOTES FOR LOGIC
===========================================================
• `swap()` exchanges characters in the array
• `findAllPermutation()` uses recursion + backtracking
• `LinkedHashSet` preserves insertion order in output
===========================================================
*/

package TCS;
import java.util.*;

public class TAG1 {

    // Utility method to swap two characters in the array
    private static void swap(char[] arr, int i, int j) {
        char temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    // Recursive function to generate all permutations
    private static void findAllPermutaion(char[] arr, int index, Set<String> res) {

        // Base case: permutation completed
        if (index == arr.length) {
            res.add(new String(arr)); // Store unique permutation
            return;
        }

        // Try placing each character at current index
        for (int i = index; i < arr.length; i++) {

            // Swap to fix character at current index
            swap(arr, i, index);

            // Recurse for next index
            findAllPermutaion(arr, index + 1, res);

            // Backtrack to restore original arrangement
            swap(arr, i, index);
        }
    }

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);

        // Read counts of 'a', 'b', and 'c'
        int n1 = sc.nextInt();
        int n2 = sc.nextInt();
        int n3 = sc.nextInt();

        // Construct the string using given counts
        String s = "a".repeat(n1) + "b".repeat(n2) + "c".repeat(n3);

        // Convert string to character array
        char[] arr = s.toCharArray();

        // Set to store unique permutations
        Set<String> res = new LinkedHashSet<>();

        // Generate permutations
        findAllPermutaion(arr, 0, res);

        // Print all unique permutations
        for (String perm : res) {
            System.out.println(perm);
        }
    }
}
